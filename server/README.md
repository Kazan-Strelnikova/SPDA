# Event planner

Я рекомендую прочитать данный файл до конца, чтобы избежать появления различных казусов 

## Пререквизиты

Перед установкой и запуском проекта необходимо, чтобы на устройстве был:

- docker
- docker-compose
- go (версия указанная [здесь](/server/go.mod))
- Taskfile (опционально, но сильно упростит процесс, [инструкция по установке](https://taskfile.dev/installation/))

## База данных

Для успешного запуска базы данных нужно создать `.env` файл, и положить туда следующие секреты:

- POSTGRES_USER
- POSTGRES_PASSWORD
- POSTGRES_DB
- POSTGRES_PORT

Например,

```env
POSTGRES_USER=planner-user
POSTGRES_PASSWORD=StrongRandomPassword123!
POSTGRES_DB=planner-db
POSTGRES_PORT=5433
```

В проекте уже имеются настроенные миграции для нашей схемы базы данных. Пример алгоритма по запоску дб:

1. Убедиться, что есть все необходимые переменные окружения
2. Запустить команду `docker-compose up -d` или `task docker-up`
3. Дождаться полной иницализации контейнера
4. Установить нужные модули: `go mod download`
5. Запустить команду `task migrate-up`. Если нет утилиты taskfile, можете подсмотреть соответствующую команду в [taskfile.yml](/server/Taskfile.yml)

## Запуск приложения 

В данной главе описан алгоритм для успешного запуска бэкенда. 

### Переменные окружения 

Вот пример полноценного .env необходимого для запуска приложения

```env
POSTGRES_USER=planner-user
POSTGRES_PASSWORD=StrongRandomPassword123!
POSTGRES_DB=planner_db
POSTGRES_PORT=5433
POSTGRES_HOST=localhost
SERVER_PORT=8080
RW_TIMEOUT=5s
IDLE_TIMEOUT=15m
```

### Старт сервиса

В данный момент приложение еще не докеризовано (upd. уже докеризовано, см. главу [Старт сервиса в Docker](#старт-сервиса-в-docker)). Перед его запуском пройдите главу связанную с базой данных. После этого используйте команду `task run`,
сервер станет доступен на порту, указанном в переменной SERVER_PORT. Как только приложение полностью запустится, эндпоинт `/ping` начнёт возвращать код 200.


### Старт сервиса в Docker

Убедитесь, что `Docker` и `Docker-compose` установлены на вашем устройстве. В данном случае, чтобы всё заработало в .env поменяйте:

- `POSTGRESS_PORT` на 5432
- `POSTGRESS_HOST` на `postgres`

Далее можно воспользоваться командами `task docker-build` и `task docker-up`.

### Описание HTTP методов

В проекте имеется [openapi.yaml](/server/openapi.yaml), который можно просмотреть, например, в [swagger ui](https://editor.swagger.io/). Для этого скопируйте содержимое файла и вставьте его в редактор `Swagger`. Значительная часть реализованных ручек там уже описана

## Логирование

Логирование системы зависит от значения переменной **ENV** в `.env`. Она может принимать 3 значения:

- Отсутствует/"local"
    - Обозначает локальное окружение
    - Лучше закомментировать сервисы `logstash`, `elasticsearch`, `kibana` в [docker-compose.yml](/server/docker-compose.yml):
    - Логи будут направлены в стандартный вывод с красивой подсветочкой
    - Уровень логирования - `DEBUG`

- "dev" 
    - Development server
    - Для данного уровня упомянутые ранее сервисы необходимы
    - Логи будут отправляться в `logstash`, в формате JSON
    - Уровень логирования - `DEBUG`

- "prod" 
    - Production server
    - Для данного уровня упомянутые ранее сервисы необходимы
    - Логи будут отправляться в `logstash`, в формате JSON
    - Уровень логирования - `INFO`

Если вы хотите потрогать серверное логирование, то вам может понадобиться VPN

Далее вы можете перейти по данному URL: http://localhost:5601/app/management/data/index_management/indices, если запускаете локально. Необходимо будет найти индекс, который будет называться в формате:

```sh
logstash-**Some_date**
```

Кибана предложит вам создать визуализацию данных, нужно будет ввести название данного индекса, остальное - по желанию. Далее вы можете писать запросы на `KQL` к данным, хранимым данным индексом.